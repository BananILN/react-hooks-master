Представим, что у нас есть приложение для создания списка задач, и мы хотим добавить новую задачу по нажатию кнопки "Добавить задачу". Каждая задача будет иметь уникальный идентификатор, который мы будем считать с помощью `uuid` библиотеки. Вот как мы можем реализовать это:

```jsx
import React, { useState } from 'react';
import { v4 as uuidv4 } from 'uuid';

function TodoApp() {
  const [tasks, setTasks] = useState([]);

  const addTask = () => {
    setTasks(prevTasks => [
      ...prevTasks,
      {
        id: uuidv4(),
        title: 'Новая задача',
        completed: false,
      },
    ]);
  };

  return (
    <div>
      <button onClick={addTask}>Добавить задачу</button>
      <ul>
        {tasks.map(task => (
          <li key={task.id}>{task.title}</li>
        ))}
      </ul>
    </div>
  );
}

export default TodoApp;
```

В этом примере при каждом нажатии кнопки "Добавить задачу" используется функциональный вариант обновления состояния, чтобы добавить новую задачу в список задач `tasks`. Функция обновления получает предыдущий массив задач `prevTasks` и возвращает новый массив задач, включая новую задачу с уникальным идентификатором, заданным с помощью `uuidv4()`. Мы используем оператор расширения (`...`) для объединения предыдущего массива задач с новой добавленной задачей.

После добавления новой задачи, мы отображаем список задач с помощью `map`, генерируя элементы списка с помощью `task.title` в качестве текста каждой задачи.

Такой подход к использованию функционального обновления состояния часто встречается в приложениях реального мира, когда нужно добавлять, удалять или изменять элементы в массиве или списках данных.

Компонент `TodoApp` представляет простой пример для понимания того, как можно использовать функциональное обновление состояния для добавления новых элементов в массив или список. Этот пример может быть доработан и расширен в реальном приложении для управления более сложным списком задач и их состояниями.