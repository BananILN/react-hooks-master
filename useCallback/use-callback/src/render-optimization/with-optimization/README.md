# WithOptimization

Компонент `WithOptimization` отображает поле ввода на экране, подсчитывает количество его рендеров с помощью `RenderCounter` и использует некешированный обработчик для текстового поля, что при изменении поля ввода вызывает перерендер вложенного компонента `Child`.

## Важные элементы кода:

### Импорт
```javascript
import {useCallback, useState} from 'react';
import RenderCounter from '../render-counter/RenderCounter';
import Child from './child/Child';
import './WithOptimization.css';
```
Отсюда мы импортируем все необходимые компоненты, включая обратный вызов и хуки состояния React.

### Хуки состояния и обратного вызова
```javascript
const [text, setText] = useState('');

    const handleChange = useCallback((event) => {
        setText(event.target.value);
    }, []);
```
Здесь мы используем `useState` для определения состояния текста, которое изменяется при каждом вводе. `useCallback` здесь используется для мемоизации обработчика `handleChange`. Благодаря мемоизации, этот обработчик сохраняет свою идентичность при каждом рендере и не вызывает повторного рендеринга дочерних компонентов.

### JSX компонента
```javascript
return (
        <div className='with-optimization-content'>
            <RenderCounter/>
            <span>Вы ввели: {text}</span>
            <Child onChange={handleChange}/>
        </div>
    );
```
Здесь формируется JSX компонента. Выводится RenderCounter, отображается введенный текст и рендерится дочерний компонент `Child`, которому передается мемоизированный обработчик `handleChange`.

## Нюансы работы компонента

Особенность данного компонента заключается в использовании хука `useCallback`. Благодаря этому у нас получается оптимизировать производительность нашего компонента и избавиться от ненужных ререндеров компонента `Child`.

Используя `useCallback`, мы "запоминаем" нашу функцию `handleChange`, что позволяет нам избегать ненужных ререндеров.

Однако стоит учесть, что `useCallback` не всегда приносит значительную выгоду. Например, если компонент редко ререндерится или не имеет больших дочерних деревьев компонентов, использование `useCallback` может быть излишним. Однако в некоторых случаях, в частности, на нашем примере, это помогает предотвратить лишнюю перерисовку.